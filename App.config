<?xml version="1.0" encoding="utf-8" ?>
<configuration>
    <startup> 
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.5" />
    </startup>
  <appSettings>
    <clear />
    <add key="概述1" value="数据就是指能够被计算机识别、存储和加工处理的信息的载体。
数据元素是数据的基本单位，可以由若干个数据项组成。数据项是具有独立含义的最小标识单位。


数据结构的定义：
	·逻辑结构：从逻辑结构上描述数据，独立于计算机。·线性结构：一对一关系。
	·线性结构：多对多关系。
　　·存储结构：是逻辑结构用计算机语言的实现。
	·顺序存储结构：如数组。
　　·链式存储结构：如链表。
　　·索引存储结构：·稠密索引：每个结点都有索引项。
　　·稀疏索引：每组结点都有索引项。
　　·散列存储结构：如散列表。
	·数据运算。
	·对数据的操作。定义在逻辑结构上，每种逻辑结构都有一个运算集合。
　　·常用的有：检索、插入、删除、更新、排序。

" />
    <add key="概述2" value="数据类型：是一个值的集合以及在这些值上定义的一组操作的总称。

结构类型：由用户借助于描述机制定义，是导出类型。

抽象数据类型ADT：
	·是抽象数据的组织和与之的操作。相当于在概念层上描述问题。
      ·优点是将数据和操作封装在一起实现了信息隐藏。

程序设计的实质是对实际问题选择一种好的数据结构，设计一个好的算法。算法取决于数据结构。

算法是一个良定义的计算过程，以一个或多个值输入，并以一个或多个值输出。
　　评价算法的好坏的因素：
	·算法是正确的；
　　·执行算法的时间；
	·执行算法的存储空间（主要是辅助存储空间）；
" />
    <add key="概述3" value="	时间复杂度：是某个算法的时间耗费，它是该算法所求解问题规模n的函数。

	渐近时间复杂度：是指当问题规模趋向无穷大时，该算法时间复杂度的数量级。

	评价一个算法的时间性能时，主要标准就是算法的渐近时间复杂度。
　　算法中语句的频度不仅与问题规模有关，还与输入实例中各元素的取值相关。
　　时间复杂度按数量级递增排列依次为：常数阶O（1）、对数阶O（log2n）、线性阶O（n）、线性对数阶O（nlog2n）、平方阶O（n^2）、立方阶O（n^3）、……k次方阶O（n^k）、指数阶O（2^n）。

　　空间复杂度：是某个算法的空间耗费，它是该算法所求解问题规模n的函数。
　　算法的时间复杂度和空间复杂度合称算法复杂度。

" />
    <add key="线性表1" value="线性表是由n≥0个数据元素组成的有限序列。
n=0是空表；非空表，只能有一个开始结点，有且只能有一个终端结点。

　　线性表上定义的基本运算：
　　·构造空表：Initlist（L）
　　·求表长：Listlength（L）
　　·取结点：GetNode（L，i）
　　·查找：LocateNode（L，x）
　　·插入：InsertList（L，x，i）
　　·删除：Delete（L，i）

" />
    <add key="线性表2" value="顺序表是按线性表的逻辑结构次序依次存放在一组地址连续的存储单元中。在存储单元中的各元素的物理位置和
逻辑结构中各结点相邻关系是一致的。地址计算：LOCa（i）=LOCa（1）+（i-1）*d；（首地址为1）
　在顺序表中实现的基本运算：
　　·插入：平均移动结点次数为n/2；平均时间复杂度均为O（n）。
    ·删除：平均移动结点次数为（n-1）/2；平均时间复杂度均为O（n）。

" />
    <add key="线性表3" value="线性表的链式存储结构中结点的逻辑次序和物理次序不一定相同，为了能正确表示结点间的逻辑关系，在存储每个结点值的同时，还存储了其后继结点的地址信息（即指针或链）。这两部分信息组成链表中的结点结构。 
一个单链表由头指针的名字来命名。
单链表运算：
·建立单链表·头插法：s->next=head；head=s；生成的顺序与输入顺序相反。平均时间复杂度均为O（n）。
·尾插法：head=rear=null；if（head=null） head=s；else r->next=s；r=s； 平均时间复杂度均为O（n）
　　·加头结点的算法：对开始结点的操作无需特殊处理，统一了空表和非空表。
　　·查找·按序号：与查找位置有关，平均时间复杂度均为O（n）。
　　·按值：与输入实例有关，平均时间复杂度均为O（n）。
　　·插入运算：p=GetNode（L，i-1）；s->next=p->next；p->next=s；平均时间复杂度均为O（n）
·删除运算：p=GetNode（L，i-1）；r=p->next；p->next=r->next；free（r）；平均时间复杂度均为O（n）

" />
    <add key="线性表4" value="单循环链表是一种首尾相接的单链表，终端结点的指针域指向开始结点或头结点。链表终止条件是以指针等于头指针或尾指针。
　　采用单循环链表在实用中多采用尾指针表示单循环链表。优点是查找头指针和尾指针的时间都是O（1），不用
遍历整个链表。
　　双链表就是双向链表，就是在单链表的每个结点里再增加一个指向其直接前趋的指针域prior，形成两条不同方
向的链。由头指针head惟一确定。
　　双链表也可以头尾相链接构成双（向）循环链表。
　　双链表上的插入和删除时间复杂度均为O （1）。

" />
    <add key="线性表5" value="顺序表和链表的比较：　　
	·基于空间：
　　 ·顺序表的存储空间是静态分配，存储密度为1；适于线性表事先确定其大小时采用。
·链表的存储空间是动态分配，存储密度＜1；适于线性表长度变化大时采用。
　　·基于时间：
　　·顺序表是随机存储结构，当线性表的操作主要是查找时，宜采用。
　　·以插入和删除操作为主的线性表宜采用链表做存储结构。
·若插入和删除主要发生在表的首尾两端，则宜采用尾指针表示的单循环链表。

" />
    <add key="栈和队列1" value="栈（Stack）是仅限制在表的一端进行插入和删除运算的线性表，称插入、删除这一端为栈顶，另一端称为栈底。表中无元素时为空栈。栈的修改是按后进先出的原则进行的，我们又称栈为LIFO表（Last In First Out）。通常栈有
顺序栈和链栈两种存储结构。
　　栈的基本运算有六种： ·构造空栈：InitStack（S）
　　·判栈空： StackEmpty（S）
　　·判栈满： StackFull（S）
　　·进栈： Push（S，x）
　　·退栈： Pop（S）
　　·取栈顶元素：StackTop（S）
　　在顺序栈中有“上溢”和“下溢”的现象。 ·“上溢”是栈顶指针指出栈的外面是出错状态。
　　·“下溢”可以表示栈为空栈，因此用来作为控制转移的条件。
　　顺序栈中的基本操作有六种：·构造空栈  ·判栈空  ·判栈满  ·进栈  ·退栈  ·取栈顶元素
	链栈则没有上溢的限制，因此进栈不要判栈满。链栈不需要在头部附加头结点，只要有链表的头指针就可以了。
链栈中的基本操作有五种：·构造空栈  ·判栈空  ·进栈  ·退栈  ·取栈顶元素

" />
    <add key="栈和队列2" value="队列（Queue）是一种运算受限的线性表，插入在表的一端进行，而删除在表的另一端进行，允许删除的一端称      
为队头（front），允许插入的一端称为队尾（rear） ，队列的操作原则是先进先出的，又称作FIFO表（First In 
First Out） .队列也有顺序存储和链式存储两种存储结构。
队列的基本运算有六种：　　·置空队：InitQueue（Q）
　·判队空：QueueEmpty（Q）
　·判队满：QueueFull（Q）
　·入队：EnQueue（Q，x）
　·出队：DeQueue（Q）
　·取队头元素：QueueFront（Q）

" />
    <add key="栈和队列3" value="队列的链式存储结构称为链队列，一个链队列就是一个操作受限的单链表。为了便于在表尾进行插入（入队）的 
操作，在表尾增加一个尾指针，一个链队列就由一个头指针和一个尾指针唯一地确定。链队列不存在队满和上溢
的问题。在链队列的出队算法中，要注意当原队中只有一个结点时，出队后要同进修改头尾指针并使队列变空。

" />
    <add key="二叉树1" value="　树是n个结点的有限集合，非空时必须满足：只有一个称为根的结点；其余结点形成m个不相交的子集，并称
根的子树。
　　根是开始结点；结点的子树数称度；度为0的结点称叶子（终端结点）；度不为0的结点称分支结点（非终端结
点）；除根外的分支结点称内部结点；
　有序树是子树有左，右之分的树；无序树是子树没有左，右之分的树；森林是m个互不相交的树的集合；
　　树的四种不同表示方法：·树形表示法；·嵌套集合表示法；·凹入表示法·广义表表示法。

" />
    <add key="二叉树2" value="二叉树的定义：是n≥0个结点的有限集，它是空集（n=0）或由一个根结点及两棵互不相交的分别称作这个根的
左子树和右子树的二叉树组成。
　　二叉树不是树的特殊情形，与度数为2的有序树不同。
　　二叉树的4个重要性质： ·二叉树上第i层上的结点数目最多为2^（i-1）（i≥1）。；
　　·深度为k的二叉树至多有（2^k）-1个结点（k≥1）；
　　·在任意一棵二叉树中，若终端结点的个数为n0，度为2的结点数为n2，则n0=n2+1；
　　·具有n个结点的完全二叉树的深度为int（log2n）+1.
　满二叉树是一棵深度为k，结点数为（2^k）-1的二叉树；完全二叉树是满二叉树在最下层自右向左去处部分结点；

" />
    <add key="二叉树3" value="二叉树的顺序存储结构就是把二叉树的所有结点按照层次顺序存储到连续的存储单元中。（存储前先将其画成完全
二叉树）
　树的存储结构多用的是链式存储。BinTNode的结构为lchild|data|rchild，把所有BinTNode类型的结点，加上一个指向根结点的BinTree型头指针就构成了二叉树的链式存储结构，称为二叉链表。它就是由根指针root唯一确定的。
共有2n个指针域，n+1个空指针。
根据访问结点的次序不同可得三种遍历：先序遍历（前序遍历或先根遍历），中序遍历（或中根遍历）、后序遍历（或
后根遍历）。时间复杂度为O（n）。

" />
    <add key="多叉树1" value="树的存储结构：·有双亲链表表示法：结点data | parent，对于求指定结点的双亲或祖先十分方便，但不适于求指定结
点的孩子及后代。
　·孩子链表表示法：为树中每个结点data | next设置一个孩子链表firstchild，并将data | firstchild存放在一个向量中。
　·双亲孩子链表表示法：将双亲链表和孩子链表结合。
　·孩子兄弟链表表示法：结点结构leftmostchild |data | rightsibing，附加两个分别指向该结点的最左孩子和右邻兄弟的
指针域。
　　树的前序遍历与相对应的二叉树的前序遍历一致；树的后序遍历与相对应的二叉树的中序遍历一致。
　　树的带权路径长度是树中所有叶结点的带权路径长度之和。树的带权路径长度最小的二叉树就称为最优二叉树
（即哈夫曼树）。
　　在叶子的权值相同的二叉树中，完全二叉树的路径长度最短。
　　
" />
    <add key="平衡二叉树1" value="平衡二叉树（Balanced Binary Tree）又被称为AVL树（有别于AVL算法），且具有以下性质：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。构造与调整方法 平衡二叉树的常用算法有红黑树、AVL、Treap等。 最小二叉平衡树的节点的公式如下 F(n)=F(n-1)+F(n-2)+1 这个类似于一个递归的数列，可以参考Fibonacci数列，1是根节点，F(n-1)是左子树的节点数量，F(n-2)是右子树的节点数量。
" />
    <add key="平衡二叉树2" value="我们知道，对于一般的二叉搜索树（Binary Search Tree），其期望高度（即为一棵平衡树时）为log2n，其各操作的时间复杂度（O(log2n)）同时也由此而决定。但是，在某些极端的情况下（如在插入的序列是有序的时），二叉搜索树将退化成近似链或链，此时，其操作的时间复杂度将退化成线性的，即O(n)。我们可以通过随机化建立二叉搜索树来尽量的避免这种情况，但是在进行了多次的操作之后，由于在删除时，我们总是选择将待删除节点的后继代替它本身，这样就会造成总是右边的节点数目减少，以至于树向左偏沉。这同时也会造成树的平衡性受到破坏，提高它的操作的时间复杂度。
平衡二叉搜索树（Balanced Binary Tree）具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。常用算法有红黑树、AVL、Treap、伸展树等。在平衡二叉搜索树中，我们可以看到，其高度一般都良好地维持在O（log2n），大大降低了操作的时间复杂度。
　　
" />
    <add key="图1" value="图的逻辑结构特征就是其结点（顶点）的前趋和后继的个数都是没有限制的，即任意两个结点之间之间都可能相关。
图GraphG=（V，E），V是顶点的有穷非空集合，E是顶点偶对的有穷集。
有向图Digraph：每条边有方向；无向图Undigraph：每条边没有方向。
有向完全图：具有n*（n-1）条边的有向图；无向完全图：具有n*（n-1）/2条边的无向图；
有根图：有一个顶点有路径到达其它顶点的有向图；简单路径：是经过顶点不同的路径；简单回路是开始和终端重
的简单路径；
网络：是带权的图。
　　
" />
    <add key="图2" value="图的存储结构：
　　·邻接矩阵表示法：用一个n阶方阵来表示图的结构是唯一的，适合稠密图。
　　·无向图：邻接矩阵是对称的。
　　·有向图：行是出度，列是入度。
建立邻接矩阵算法的时间是O（n+n^2+e），其时间复杂度为O（n^2）
　　·邻接表表示法：用顶点表和邻接表构成不是唯一的，适合稀疏图。
·顶点表结构 vertex | firstedge，指针域存放邻接表头指针。
·邻接表：用头指针确定。 ·无向图称边表；
·有向图又分出边表和逆邻接表；
·邻接表结点结构为 adjvex | next，
　　时间复杂度为O（n+e）。，空间复杂度为O（n+e）。。
" />
    <add key="图3" value="图的遍历： ·深度优先遍历：借助于邻接矩阵的列。使用栈保存已访问结点。
　　·广度优先遍历：借助于邻接矩阵的行。使用队列保存已访问结点。
　　生成树的定义：若从图的某个顶点出发，可以系统地访问到图中所有顶点，则遍历时经过的边和图的所有顶点
构成的子图称作该图的生成树。
　　最小生成树：图的生成树不唯一，从不同的顶点出发可得到不同的生成树，把权值最小的生成树称为最小生成树
（MST）。
　　构造最小生成树的算法： ·Prim算法的时间复杂度为O（n^2）与边数无关适于稠密图。
　　·Kruskal算法的时间复杂度为O（lge），主要取决于边数，较适合于稀疏图。
　　最短路径的算法：·Dijkstra算法，时间复杂度为O（n^2）。·类似于prim算法。
　　　　
" />
  </appSettings>
</configuration>